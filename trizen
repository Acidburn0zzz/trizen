#!/usr/bin/perl

# Coded by Trizen (http://trizen.go.ro)
# Created on:  07 July 2010, 12:00 PM
# Rewritten on: 16 February 2011
# Last edit on: 20 February 2011
# Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d

use File::Path;

$a = $ARGV[0];
unless ($a) {
    $a = '';
}
if ($a and not $ARGV[1]) {
    unless ($a =~ /[-]+(S[y]?u|(R|r)ss|(n|N)|Q.*|h|help)$/) {
        unless ($a =~ /^-Sc[c]?$/) {
            if ($a =~ /^-/) {
                &die;
            }
        }
    }
}
$makeconf_file = "$ENV{'HOME'}/.config/trizen-makepkg.conf";
$usermake = "makepkg -s -f --install --config $makeconf_file";
$rootmake = $usermake . ' --asroot';
$cache_dir = '/tmp/trizen';
$rpc = 'http://aur.archlinux.org/rpc.php?type=';
$info = 'http://aur.archlinux.org/rpc.php?type=info&arg=';
$aur_pkgs = 'http://aur.archlinux.org/packages/';
$aur_website = 'http://aur.archlinux.org/packages.php?ID=';
$lastline = '';
$lastdep = '';
$all_argvs = '';
$whoami = `whoami`;
if ($whoami ne "root\n") {
    chomp($user = $whoami);
    $location = "$cache_dir-$user";
    mkdir $location;
}
else {
    $location = "$cache_dir-root";
    mkdir $location;
}
$cache_dir = $location;
open CONF, '/etc/makepkg.conf';
open RECONF, '>', $makeconf_file;
while (defined($_ = <CONF>)) {
    if (not $_ =~ /PKGEXT='(.+)/) {
        print RECONF $_;
    }
    else {
        print RECONF "PKGEXT='.pkg.tar.gz'\n";
    }
}
foreach $_ (@ARGV) {
    if ($_ =~ /^[-]+(q|quiet)$/) {
        $quiet = 1;
    }
    if ($_ eq '-G') {
        $tarball_only = 1;
    }
    if ($_ eq '-Ssq') {
        $quiet = 1;
    }
    if ($_ =~ /^[-]+(nc$|nocolor)/) {
        $nocolors = 1;
    }
    if ($_ =~ /^[-]+(nd$|nodesc)/) {
        $nodesc = 1;
    }
    if ($_ =~ /^[-]+devel/) {
        $devel = 1;
    }
    if ($_ =~ /^[-]+(mvpkg|movepkg)/) {
        $movepkg = 1;
    }
    if ($_ eq '--noconfirm') {
        $noconfirm = 1;
        $usermake .= ' --noconfirm';
        $rootmake .= ' --noconfirm';
    }
    if ($_ eq '--skipinteg') {
        $usermake .= ' --skipinteg';
        $rootmake .= ' --skipinteg';
    }
    if ($_ =~ /^[-]+noedit/) {
        $noedit = 1;
    }
    if ($_ =~ /^[-]+needed/) {
        $needed = 1;
    }
}
if (not $nocolors) {
    $bred = "\e[1;31m";
    $bgreen = "\e[1;32m";
    $red = "\e[0;31m";
    $green = "\e[0;32m";
    $cgreen = "\e[42m";
    $cblack = "\e[40m";
    $byellow = "\e[1;33m";
    $reset = "\e[0m";
}
else {
    $bred = '';
    $bgreen = '';
    $red = '';
    $green = '';
    $cgreen = '';
    $cblack = '';
    $byellow = '';
    $reset = '';
}
if (not @ARGV or $a =~ /^[-]+(h|help)$/) {
    &help;
}
for ($nr = 0; $nr <= $#ARGV; ++$nr) {
    push @args1, "$ARGV[$nr] ";
    push @all_argvs, " $ARGV[$nr] ";
}
foreach $arg1 (@args1) {
    unless ($arg1 =~ /^-/) {
        push @args, $arg1;
    }
}
foreach $keyword (@args) {
    $keyword =~ s/[\s]+//g;
    push @keys, $keyword . '[^"]*';
}
unless ($quiet) {
    $quiet = '';
}
$all_argvs = join('', @all_argvs);
if ($all_argvs =~ / -Sc[c]? /) {
    print "\n[!] Removing $location\n";
    rmtree($location);
    print "[*] Done.\n\n";
    exit;
}
sub help {
    die "
\t   ............${bgreen}TRIZEN AUR PACKAGE MANAGER$reset............

  ${bgreen}usage:$reset trizen [option] [pkgname] [pkgname] [...]

$bred*$reset Base options
    -S          : installs package
    -Ss         : searches for package
    -Si         : outputs info for package
    -Sp         : outputs only PKGBUILD
    -Su         : upgrades all AUR packages
    -Sc         : clears trizen pakage-kit cache
    -R.*        : removes packages with pacman
    -Qm         : outputs AUR installed packages
    -Qs         : searches for installed packages
    -Ssq        : searches for package in quiet mode
    -G          : download and extract AUR tarball only
    -N,-Rss     : outputs the AUR Newest Packages (RSS)

$bred*$reset Other options
    -q          : quiet mode
    -nc         : no color for text
    -nd         : no description for search results
    --movepkg   : after build, move pkg to the home directory
    --needed    : don't reinstall up to date packages
    --noedit    : do not prompt to edit files
    --devel     : update devel packages during -Su
    --noconfirm : do not prompt for any confirmation
    --skipinteg : when using makepkg, do not check md5s
    --help      : outputs this message

$bred*$reset Example: trizen -S bleachbit youtube-viewer -q --movepkg

";
}
sub die {
    die "\n  Try:\n\t$0 $a [pkgname]\n\n";
}
require LWP::UserAgent;
$lwp = 'LWP::UserAgent'->new;
$lwp->agent('Mozilla/5.0 (CLI; Trizen AUR Package Manager; U; en) Trizen/0.9');
$pacmanq = "\n" . `pacman -Qq` . "\n";
if ($all_argvs =~ / -(Q|R)/ and not $all_argvs =~ / [-]+rss /i) {
    if ($all_argvs =~ / -Q/) {
        exec "pacman $all_argvs";
    }
    elsif ($all_argvs =~ / -R/) {
        if ($whoami eq "root\n") {
            exec "pacman $all_argvs";
        }
        else {
            print 'Root ';
            exec qq[su -c "pacman $all_argvs"];
        }
    }
}
if ($tarball_only) {
    foreach $pkg (@args) {
        $lwp->mirror("http://aur.archlinux.org/packages/$pkg/$pkg.tar.gz", "$pkg.tar.gz");
        if (-e "$pkg.tar.gz") {
            unless ($quiet) {
                print "$bred*$reset Unpacking $pkg.tar.gz\n";
            }
            `tar xf $pkg.tar.gz`;
        }
        else {
            print "$bred!$reset error:$pkg doesn't exit\n";
            next;
        }
    }
    print "\n$bred*$reset Done...\n";
}
if ($all_argvs =~ / -S[y]?u /) {
    &Update;
}
if ($all_argvs =~ / -Sp /) {
    foreach $pkgname (@args) {
        print "\n$bred=>>$reset PKGBUILD for $pkgname\n";
        $pkgbuild = $lwp->get("$aur_pkgs$pkgname/$pkgname/PKGBUILD");
        print $pkgbuild->content;
        print "\n";
    }
    exit;
}
if ($all_argvs =~ / -Ss[q]? /) {
    $keywords = join(' ', @args);
    if ($all_argvs =~ / -Ss /) {
        system "pacman -Ss $keywords";
    }
    else {
        system "pacman -Ssq $keywords";
    }
    $rpc .= 'search';
    foreach $keyword (@args) {
        $rpc .= "&arg=$keyword";
    }
    $connect = $lwp->get($rpc);
    @results = split(/"ID":/, $connect->content, 0);
}
if ($all_argvs =~ / -Ss[q]? /) {
    foreach $result (@results) {
        &Check_result;
    }
    &Parse_results;
}
sub Check_aur_deps {
    ++$n;
    $aur_url = "http://aur.archlinux.org/packages.php?ID=$id";
    unless ($checked or $quiet) {
        print "$bred=>> $cblack${byellow}Checking for AUR deps$reset\n";
        $checked = 1;
    }
    unless ($quiet) {
        print "$bred*$reset AUR - $aur_url\n";
    }
    $connect = $lwp->get($aur_url);
    if ($connect->content =~ m[([^/]+)/PKGBUILD]) {
        $dep_name = $1;
        if ($dep_name ne $pkgname and not $check_deps =~ /\#$dep_name$|^$dep_name\#|\#$dep_name\#|^$dep_name$/) {
            push @final_aur_deps, $1;
        }
    }
    $aur_deps = $connect->content;
    $aur_deps =~ s[</a>][\n]g;
    @aur_deps = split(/\n/, $aur_deps, 0);
    foreach $line (@aur_deps) {
        next if $line eq $lastline;
        $check_deps = join('#', @final_aur_deps);
        unless ($check_deps) {
            $check_deps = 'NULL';
        }
        if ($line =~ /do_Orphans=&SeB='>(.+)/) {
            $dep = $1;
            $dep =~ s/[<>]+.+//;
            $dep =~ s/=.+//;
            if ($check_deps =~ /\#$lastdep$|^$lastdep\#|\#$lastdep\#|^$lastdep$/ and $id ne $firstid and not $check_deps =~ /\#$dep$|^$dep\#|\#$dep\#|^$dep$/) {
                unshift @final_aur_deps, $dep;
            }
            elsif (not $check_deps =~ /\#$dep$|^$dep\#|\#$dep\#|^$dep$/) {
                push @final_aur_deps, $dep;
            }
            $lastdep = $dep;
            unless ($quiet) {
                print "    $bred>$reset Found: $lastdep\n";
            }
        }
        if ($line =~ m[packages/search/\?q=([^']+)]) {
            $pac_dep = $1;
            $pac_dep =~ s/[<>]+.+//;
            $pac_dep =~ s/=.+//;
            push @pacman_deps, $1;
        }
        $lastline = $line;
    }
}
sub Install {
    foreach $pkg (@packages_for_install) {
        $installed = "\n" . `pacman -Q` . "\n";
        next if $installed =~ /\n$pkg\n/;
        $connect = $lwp->get("$info$pkg");
        next if $connect->content =~ /"results":"No result found"/;
        $tarball = "http://aur.archlinux.org/packages/$pkg/$pkg.tar.gz";
        unless ($quiet) {
            print "\n$bred*$reset Downloading '${pkg}' tarball\n";
        }
        $lwp->mirror($tarball, "$cache_dir/$pkg.tar.gz");
        unless ($quiet) {
            print "$bred*$reset Saved as $cache_dir/$pkg.tar.gz\n";
            print "$bred*$reset Done.\n\n";
            print "$bred*$reset Unpacking tarball...\n";
        }
        `tar xf $cache_dir/$pkg.tar.gz -C $cache_dir`;
        if ($ENV{'EDITOR'}) {
            $editor = $ENV{'EDITOR'};
        }
        elsif (-e '/usr/bin/joe') {
            $editor = 'joe';
        }
        elsif (-e '/usr/bin/nano') {
            $editor = 'nano';
        }
        elsif (-e 'usr/bin/vim') {
            $editor = 'vim';
        }
        elsif (-e '/usr/bin/vi') {
            $editor = 'vi';
        }
        next unless open FILE, "$cache_dir/$pkg/PKGBUILD";
        @file = <FILE>;
        close FILE;
        print "\n$bred=>>$reset PKGBUILD of $pkg\n\n";
        print @file;
        print "\n";
        unless ($noconfirm or $noedit) {
            print "$bred=>>$reset Edit $cblack$byellow$pkg$reset PKGBUILD with '${editor}'? (y/N)\n> ";
            chomp($yn = <STDIN>);
            if ($yn =~ /^y/i) {
                system "$editor $cache_dir/$pkg/PKGBUILD";
            }
        }
        chdir "$cache_dir/$pkg";
        if ($whoami eq "root\n") {
            system $rootmake;
        }
        else {
            system $usermake;
        }
        if ($movepkg) {
            if (`ls $cache_dir/$pkg` =~ /(.+)\.pkg\.tar(.*)/) {
                `mv $cache_dir/$pkg/$& $ENV{'HOME'}`;
            }
        }
    }
}
sub Update {
    @aur_pkgs = `pacman -Qm`;
    foreach $_ (@aur_pkgs) {
        chomp($line = $_);
        next unless $line;
        unless ($devel) {
            next if $line =~ /-git |^.+ 20(09|1(0|1|2))[\d]+|-svn/;
        }
        if ($line =~ /(.+) (.+)/) {
            $pkgname = $1;
            $vers = $2;
        }
        if ($lwp->get("$info$pkgname")->content =~ /"Name":"([^"]+)".*Version":"([^"]+)".*OutOfDate":"([\d]+)"/) {
            $name = $1;
            $vvv = $2;
            $ood = $3;
            if ($vers ne $vvv) {
                $vers_nr = $vers;
                $vers_nr =~ s/[^\d]+|^[0]+//g;
                $vvv_nr = $vvv;
                $vvv_nr =~ s/[^\d]+|^[0]+//g;
                if ($vvv_nr > $vers_nr and not $devel) {
                    push @packages_for_install, $name;
                    push @for_upgrade, "$bred*$reset $name $bred$vers$reset -> $bgreen$vvv$reset\n";
                }
                else {
                    push @packages_for_install, $name;
                    push @for_upgrade, "$bred*$reset $name $bred$vers$reset -> $bgreen$vvv$reset\n";
                }
            }
            $v2 = $vvv;
            if ($ood eq 1) {
                $v2 = 'ood';
            }
            print "$bred*$reset $line";
            if ($vers eq $vvv) {
                if ($v2 eq 'ood') {
                    print $bred . ' (out-of-date)';
                    print $reset;
                }
                print "\n";
            }
            elsif ($vvv ne $vers) {
                if ($vvv_nr > $vers_nr) {
                    print " $bgreen(New Update: $vvv)$reset";
                }
                else {
                    print " (${bgreen}AUR Version: $bred$vvv$reset)";
                }
                if ($v2 eq 'ood') {
                    print " $bred(out-of-date)$reset";
                }
                print "\n";
            }
        }
    }
    if (@packages_for_install) {
        print "\n";
        print @for_upgrade;
        print "\n";
        print "$bred=>>$reset Proceed with upgrade? (Y/n)\n> ";
        chomp($yn = <STDIN>);
        if ($yn =~ /^y|^$/i) {
            &Install;
        }
        else {
            exit;
        }
    }
    else {
        print "\n$bgreen* Your AUR Packages are up to date.\n\n";
        exit;
    }
}
if ($all_argvs =~ / -S /) {
    foreach $pkgname (@ARGV) {
        next if $pkgname =~ /^-/;
        $checked = '';
        $pkg = $pkgname;
        $installing = 1;
        &Info;
        splice @packages_for_install;
        splice @pacman_deps;
        splice @final_aur_deps;
        splice @pacman_deps2;
        splice @deps_ids;
        if ($connect->content =~ /"results":"No result found"/) {
            $check_pacman = `pacman -S --print $pkgname`;
            if ($check_pacman =~ m[://]) {
                print "\n$bred=>>$reset Installing '$bgreen$pkgname${reset}' with pacman\n";
                if ($whoami eq "root\n") {
                    if ($needed) {
                        system "pacman -S $pkgname --needed";
                    }
                    else {
                        system "pacman -S $pkgname";
                    }
                }
                else {
                    print "\nRoot ";
                    if ($needed) {
                        system qq[su -c "pacman -S $pkgname --needed"];
                    }
                    else {
                        system qq[su -c "pacman -S $pkgname"];
                    }
                }
                next;
            }
            else {
                next;
            }
        }
        if ($connect->content =~ /"OutOfDate":"1"/) {
            $out_of_date = 1;
        }
        if ($connect->content =~ /"ID":"([^"]+)"/) {
            $id = $1;
            unless ($firstid) {
                $firstid = $id;
            }
            foreach $AUR_dep (@all_depends) {
                unless ($pacmanq =~ /\n$AUR_dep\n/) {
                    $check_aur = 1;
                }
            }
            if ($check_aur) {
                &Check_aur_deps;
            }
            if ($pkgbuild_connect->content =~ /makedepends[\s]*=[\s]*([^\w]*)([^\)]*)/ and not $pkgbuild_connect->content =~ /makedepends[\s]*=[\s]*\([\s'"]*\)/) {
                $makedepends = $2;
                $makedepends =~ s/[<>]+[^' "]+//g;
                $makedepends =~ s/=[^' "]+//g;
                $makedepends =~ s/([^\w\-\+]+)/\n/g;
                until (not $makedepends =~ /\n\n/) {
                    $makedepends =~ s/\n\n/\n/g;
                }
                @makedepends = split(/\n/, $makedepends, 0);
                foreach $makedepend (@makedepends) {
                    $info_connect = $lwp->get("$info$makedepend");
                    if ($info_connect->content =~ /"ID":"([^"]+)"/) {
                        push @deps_ids, $1;
                    }
                    unless ($info_connect->content =~ /"results":"No result found"/) {
                        next;
                    }
                    if (not $pacmanq =~ /\n$makedepend\n/) {
                        if ($makedepend eq 'pkgconfig') {
                            $makedepend = 'pkg-config';
                        }
                    }
                    else {
                        next;
                    }
                    unless ($pacmanq =~ /\n$makedepend\n/) {
                        push @pacman_deps, $makedepend;
                    }
                }
            }
        }
        foreach $aur_dep (@final_aur_deps) {
            next if $pacmanq =~ /\n$aur_dep\n/ or $aur_dep eq $pkgname;
            $info_connect = $lwp->get("$info$aur_dep");
            if ($info_connect->content =~ /"ID":"([^"]+)"/) {
                push @deps_ids, $1;
            }
        }
        if (@deps_ids) {
            unless ($n) {
                $n = 0;
            }
            foreach $id (@deps_ids) {
                &Check_aur_deps;
            }
        }
        if ($check_aur) {
            print "\n";
        }
        print "${bred}[!]$reset $cblack${byellow}From AUR:$reset ";
        foreach $aur_dep (@final_aur_deps) {
            next if $pacmanq =~ /\n$aur_dep\n/;
            if ($aur_dep) {
                print "$aur_dep ";
                push @packages_for_install, $aur_dep;
            }
        }
        print "$pkgname ";
        $check_deps = join('#', @packages_for_install);
        $check_deps =~ s/$pkgname#//g;
        $check_deps =~ s/#$|^#//;
        @packages_for_install = split(?#?, $check_deps, 0);
        push @packages_for_install, $pkgname;
        foreach $dep (@pacman_deps) {
            push @pacman_deps2, "$dep ";
        }
        $pacman_deps = join('', @pacman_deps2);
        $pacman_deps =~ s/[\s]+/ /g;
        until (not $pacman_deps =~ /  /) {
            $pacman_deps =~ s/  / /g;
        }
        @pacman_deps = split(' ', $pacman_deps, 0);
        @pacman_deps = sort  @pacman_deps;
        $pac_printed = '';
        foreach $dep (@pacman_deps) {
            next if $dep eq 'sh';
            next if $dep eq $lastdep;
            unless ($pacmanq =~ /\n$dep\n/) {
                unless ($pac_printed) {
                    print "\n${bgreen}[*] $cblack${byellow}From Pacman:$reset ";
                    $pac_printed = 1;
                }
                print "$dep ";
            }
            $lastdep = $dep;
        }
        if ($out_of_date) {
            print "\n\n$bred!$reset warning: '${pkgname}' has been flagged out of date";
        }
        if ($pacmanq =~ /\n$pkgname\n/) {
            if ($out_of_date) {
                print "\n";
            }
            else {
                print "\n\n";
            }
            if ($needed) {
                print "$bred!$reset warning: '${pkgname}' is already installed --skipping\n\n";
                next;
            }
            print "$bred!$reset warning: '${pkgname}' is already installed --reinstalling";
        }
        unless ($noconfirm) {
            print "\n\n$bred=>>$reset Proceed with build (Y/n)\n> ";
            chomp($yn = <STDIN>);
            unless ($yn =~ /^y|^$/i) {
                next;
            }
        }
        &Install;
    }
}
sub Check_result {
    $keyword = join('', @keys);
    if ($result =~ /"Name":"[^"]*$keyword"/i) {
        push @final_results, $result;
    }
    elsif ($all_argvs =~ / -Ss[q]? / and $result =~ /"Description":"[^"]*$keyword"/i) {
        push @final_results, $result;
    }
}
sub Parse_results {
    $n = 0;
    foreach $result (@final_results) {
        if ($result =~ /"([\d]+)","Name":"([^"]+)","Version":"([^"]*)","CategoryID":"([\d]+)","Description":"([^"]*)"/) {
            $id = $1;
            $name = $2;
            $ver = $3;
            $cat = $4;
            $desc = $5;
            ++$n;
        }
        if ($result =~ /"URL":"([^"]*)","URLPath":"([^"]*)","License":"([^"]*)","NumVotes":"([^"]*)","OutOfDate":"([^"]*)"/) {
            $url = $1;
            $votes = $4;
            $ood = $5;
        }
        $url =~ s[\\/][/]g;
        $desc =~ s[\\/][/]g;
        if ($all_argvs =~ / -Ss[q]? /) {
            &Print_results;
        }
    }
}
sub Print_results {
    &Parse_category;
    unless ($quiet) {
        print "$green$n. $bgreen";
    }
    print "$cblack$byellow$name$reset ";
    unless ($quiet) {
        print "$ver ";
        if ($pacmanq =~ /\n$name\n/) {
            print "[$cgreen${byellow}installed$reset] ";
        }
        if ($ood eq 1) {
            print "[${bred}out-of-date$reset] ";
        }
        print "($votes+) ($cat) ";
        unless ($nodesc) {
            print "$desc ";
        }
    }
    print "$reset\n";
}
sub Parse_category {
    $cat =~ s/^2$/daemons/;
    $cat =~ s/^3$/devel/;
    $cat =~ s/^4$/editors/;
    $cat =~ s/^5$/emulators/;
    $cat =~ s/^6$/games/;
    $cat =~ s/^7$/gnome/;
    $cat =~ s/^8$/i18n/;
    $cat =~ s/^9$/kde/;
    $cat =~ s/^19$/kernels/;
    $cat =~ s/^10$/lib/;
    $cat =~ s/^11$/modules/;
    $cat =~ s/^12$/multimedia/;
    $cat =~ s/^13$/network/;
    $cat =~ s/^14$/office/;
    $cat =~ s/^15$/science/;
    $cat =~ s/^16$/system/;
    $cat =~ s/^17$/x11/;
    $cat =~ s/^18$/xfce/;
}
if ($all_argvs =~ / [-]+(n|rss) /i) {
    $url = 'http://aur.archlinux.org/rss.php';
    $connect = $lwp->get($url);
    $rss = $connect->content;
    $rss =~ s/&quot;/"/g;
    $rss =~ s/&amp;/&/g;
    $rss =~ s[</link>[\s]*\n[\s]*<description>|</author>[\s]*\n[\s]*<pubDate>|</title>[\s]*\n[\s]*<link>|</description>[\s]*\n[\s]*<author>][---]g;
    @RSS = split(?\n?, $rss, 0);
    foreach $_ (@RSS) {
        if ($_ =~ m[<title>(.+)---(.+)---(.+)---(.+)---(.+)</pubDate>]) {
            print $green;
            print "\nTitle:";
            print $bgreen . "\t$1$reset\n";
            print $green;
            print 'Descr:';
            print "$green\t$3\n";
            print $green;
            print 'A.URL:';
            print $red . "\t$2\n";
            print $reset;
        }
    }
    print "\n";
    exit;
}
if ($all_argvs =~ / -Si /) {
    foreach $pkg (@args) {
        &Info;
    }
}
sub Info {
    $pkgbuild = "http://aur.archlinux.org/packages/$pkg/$pkg/PKGBUILD";
    $connect = $lwp->get("$info$pkg");
    if ($connect->content =~ /"results":"No result found"/) {
        if ($installing) {
            return;
        }
        system "pacman -Si $pkg";
        next;
    }
    if ($connect->content =~ /"ID":"([^"]+)/) {
        $aur_id = $1;
    }
    if ($connect->content =~ /"NumVotes":"([^"]+)/) {
        $votes = $1;
    }
    if ($connect->content =~ /"OutOfDate":"([\d]+)/) {
        $out_of_date = $1;
    }
    if ($connect->content =~ /"Name":"([^"]+)/) {
        $pkg = $1;
    }
    if ($connect->content =~ /"Version":"([^"]+)/) {
        $pkgver = $1;
    }
    if ($connect->content =~ /"Description":"([^"]*)/) {
        $description = $1;
        $description =~ s[\\/][/]g;
        $description =~ s/&quot;/"/g;
        $description =~ s/&amp;/&/g;
    }
    if ($connect->content =~ /"URL":"([^"]*)/) {
        $url = $1;
        $url =~ s[\\/][/]g;
    }
    if ($connect->content =~ /"CategoryID":"([^"]+)/) {
        $cat = $1;
        &Parse_category;
    }
    $pkgbuild_connect = $lwp->get($pkgbuild);
    if ($pkgbuild_connect->content =~ /\ndepends[\s]*=[\s]*\(([^\)]*)/) {
        $depends = $1;
        $depends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $depends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $depends =~ s/"|'//g;
        $depends =~ s/\n[\s]*/\n\t\t  /g;
        $depends =~ s/\\//g;
    }
    if ($pkgbuild_connect->content =~ /\nmakedepends[\s]*=[\s]*\(([^\)]*)/) {
        $makedepends = $1;
        $makedepends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $makedepends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $makedepends =~ s/"|'//g;
        $makedepends =~ s/\n[\s]*/\n\t\t  /g;
        $makedepends =~ s/\\//g;
    }
    else {
        $makedepends = 'None';
    }
    if ($pkgbuild_connect->content =~ /\noptdepends[\s]*=[\s]*\(([^\)]*)/) {
        $optdepends = $1;
        $optdepends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $optdepends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $optdepends =~ s/"|'//g;
        $optdepends =~ s/\n[\s]*/\n\t\t  /g;
        $optdepends =~ s/\\//g;
    }
    else {
        $optdepends = '';
    }
    $all_depends = "$depends ";
    if ($makedepends ne 'None') {
        $all_depends .= $makedepends;
    }
    $all_depends =~ s/^[\s]+|[\s]+$//g;
    $all_depends =~ s/[\s]+/ /g;
    $all_depends =~ s/[<>]+[^\s]+//g;
    $all_depends =~ s/=[^\s]+//g;
    @all_depends = split(' ', $all_depends, 0);
    if ($pkgbuild_connect->content =~ /\nlicense[\s]*=[\s]*(.+)/) {
        $license = $1;
        $license =~ s/[")(']//g;
        $license =~ s/#(.*)//;
    }
    else {
        $license = '';
    }
    if ($pkgbuild_connect->content =~ /\ngroups[\s]*=[\s]*(.+)/) {
        $groups = $1;
        $groups =~ s/['"\)\(]+//g;
    }
    else {
        $groups = '';
    }
    if ($pkgbuild_connect->content =~ /\nprovides[\s]*=[\s]*(.+)/) {
        $provides = $1;
        $provides =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $provides =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $provides =~ s/['"\)\(]+//g;
    }
    else {
        $provides = '';
    }
    if ($pkgbuild_connect->content =~ /\nconflicts[\s]*=[\s]*(.+)/) {
        $conflicts = $1;
        $conflicts =~ s/['"\(\)]+//g;
        $conflicts =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $conflicts =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
    }
    else {
        $conflicts = '';
    }
    if ($pkgbuild_connect->content =~ /\nreplaces[\s]*=[\s]*(.+)/) {
        $replaces = $1;
        $replaces =~ s/['"\)\(]+//g;
        $replaces =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $replaces =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
    }
    else {
        $replaces = '';
    }
    if ($pkgbuild_connect->content =~ /\narch[\s]*=[\s]*(.+)/) {
        $arch = $1;
        $arch =~ s/['"\(\)]+//g;
    }
    unless ($url =~ /[\w]+/) {
        $url = 'None';
    }
    unless ($groups =~ /[\w]+/) {
        $groups = 'None';
    }
    unless ($optdepends =~ /[\w]+/) {
        $optdepends = 'None';
    }
    unless ($provides =~ /[\w]+/) {
        $provides = 'None';
    }
    unless ($conflicts =~ /[\w]+/) {
        $conflicts = 'None';
    }
    unless ($replaces =~ /[\w]+/) {
        $replaces = 'None';
    }
    if ($pacmanq =~ /\n$pkg\n/) {
        $yn = 'Yes';
    }
    else {
        $yn = 'No';
    }
    print "\n$bred*$reset Repository\t: ${bred}AUR\n";
    print "$bred*$reset Name\t\t: $bgreen$pkg\n";
    print "$bred*$reset Version\t: $pkgver\n";
    print "$bred*$reset Category\t: $cat\n";
    print "$bred*$reset Out Of Date\t: ";
    if ($out_of_date eq 1) {
        print "${bred}Yes\n";
    }
    else {
        print "No\n";
    }
    print "$bred*$reset Installed\t: ";
    if ($yn eq 'Yes') {
        print "${bgreen}Yes\n";
    }
    else {
        print "No\n";
    }
    print "$bred*$reset Votes\t\t: $votes\n";
    print "$bred*$reset URL\t\t: $url\n";
    print "$bred*$reset AUR URL\t: $bgreen$aur_website$aur_id\n";
    print "$bred*$reset License";
    if ($license =~ /[\w]+ [\w]+/) {
        print 's';
    }
    print "\t: $license\n";
    print "$bred*$reset Groups\t: $groups\n";
    print "$bred*$reset Provides\t: $provides\n";
    print "$bred*$reset Depends On\t: $depends\n";
    print "$bred*$reset Make Depends\t: $makedepends\n";
    print "$bred*$reset Optional Deps\t: $optdepends\n";
    print "$bred*$reset Conflicts\t: ";
    if ($conflicts ne 'None') {
        print "$bred";
    }
    print "$conflicts\n";
    print "$bred*$reset Replaces\t: $replaces\n";
    print "$bred*$reset Architecture\t: $arch\n";
    print "$bred*$reset Description\t: $description\n\n";
}
exit;
