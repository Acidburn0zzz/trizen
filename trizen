#!/usr/bin/perl
#
# Copyright (C) 2010-2011 Trizen <echo dHJpemVueEBnbWFpbC5jb20K | base64 -d>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# Coded by Trizen (http://trizen.go.ro)
# Created on:  07 July 2010, 12:00 PM
# Rewritten on: 16 February 2011
# Latest edit on: 29 March 2011
# Email: echo dHJpemVueEBnbWFpbC5jb20K | base64 -d

use HTML::Entities;

$a = $ARGV[0];
unless ($a) {
    $a = '';
}
if ($a and not $ARGV[1]) {
    unless ($a =~ /[-]+(S[y]?u|(n|N)|Q.*|h|help)$/) {
        unless ($a =~ /^-Sc[c]?$|-U/) {
            if ($a =~ /^-/) {
                &die;
            }
        }
    }
}
unless (-r "$ENV{'HOME'}/.config/") {
    mkdir "$ENV{'HOME'}/.config/";
}
$makeconf_file = "$ENV{'HOME'}/.config/trizen-makepkg.conf";
$usermake = "makepkg -s -f --install --config $makeconf_file";
$rootmake = $usermake . ' --asroot';
$cache_dir = '/tmp/trizen';
$rpc = 'http://aur.archlinux.org/rpc.php?type=';
$info = 'http://aur.archlinux.org/rpc.php?type=info&arg=';
$aur_pkgs = 'http://aur.archlinux.org/packages/';
$aur_website = 'http://aur.archlinux.org/packages.php?ID=';
$lastline = '';
$lastdep = '';
$all_argvs = '';
$show_comments = 1;
$whoami = `whoami`;
if (-e '/usr/bin/sudo') {
    $cvr = 'sudo';
} else {
    $cvr = 'su -c';
}
if ($whoami ne "root\n") {
    chomp($user = $whoami);
    $location = "$cache_dir-$user";
    mkdir $location;
} else {
    $location = "$cache_dir-root";
    mkdir $location;
}
$cache_dir = $location;
unless (-e $makeconf_file) {
    open CONF, '/etc/makepkg.conf';
    open RECONF, '>', $makeconf_file;
    while (defined($_ = <CONF>)) {
        if (not $_ =~ /PKGEXT='(.+)/) {
            print RECONF $_;
        } else {
            print RECONF "PKGEXT='.pkg.tar.gz'\n";
        }
    }
}
foreach $_ (@ARGV) {
    if ($_ =~ /^[-]+(q|quiet)$/) {
        $quiet = 1;
    }
    if ($_ eq '-G') {
        $tarball_only = 1;
    }
    if ($_ eq '-Ssq') {
        $quiet = 1;
    }
    if ($_ =~ /^[-]+(nc$|nocolor)/) {
        $nocolors = 1;
    }
    if ($_ =~ /^[-]+(nd$|nodesc)/) {
        $nodesc = 1;
    }
    if ($_ =~ /^[-]+devel$/) {
        $devel = 1;
    }
    if ($_ =~ /^[-]+(mvpkg|movepkg)$/) {
        $movepkg = 1;
    }
    if ($_ =~ /^[-]+(C$|no[-]?comment)/) {
        $show_comments = '';
    }
    if ($_ eq '--auronly') {
        $auronly = 1;
    }
    if ($_ eq '--noconfirm') {
        $noconfirm = 1;
        $usermake .= ' --noconfirm';
        $rootmake .= ' --noconfirm';
    }
    if ($_ eq '--skipinteg') {
        $usermake .= ' --skipinteg';
        $rootmake .= ' --skipinteg';
    }
    if ($_ =~ /^[-]+noedit/) {
        $noedit = 1;
    }
    if ($_ =~ /^[-]+needed/) {
        $needed = 1;
    }
}
if (not $nocolors) {
    $bred = "\e[1;31m";
    $bgreen = "\e[1;32m";
    $red = "\e[0;31m";
    $green = "\e[0;32m";
    $cgreen = "\e[42m";
    $cblack = "\e[40m";
    $byellow = "\e[1;33m";
    $reset = "\e[0m";
} else {
    $bred = '';
    $bgreen = '';
    $red = '';
    $green = '';
    $cgreen = '';
    $cblack = '';
    $byellow = '';
    $reset = '';
}
if (not @ARGV or $a =~ /^[-]+(h|help)$/) {
    &help;
}
for ($nr = 0; $nr <= $#ARGV; ++$nr) {
    push @all_argvs, " $ARGV[$nr] ";
}
foreach my $arg (@ARGV) {
    unless ($arg =~ /^-/) {
        push @args, $arg;
    }
}
foreach $keyword (@args) {
    $keyword =~ s/[\s]+//g;
    my $keyword = quotemeta $keyword;
    push @keys, $keyword . '[^"]*';
}
unless ($quiet) {
    $quiet = '';
}
$all_argvs = join('', @all_argvs);
if ($all_argvs =~ / -Sc[c]? /) {
    require File::Path;
    print "\n[!] Removing $location\n";
    File::Path::rmtree($location);
    print "[*] Done.\n\n";
    exit;
}
sub help {
    die "
\t   ............${bgreen}TRIZEN AUR PACKAGE MANAGER$reset............

  ${bgreen}usage:$reset trizen [option] [pkgname] [pkgname] [...]

$bred*$reset Base options
    -S          : installs package
    -Ss         : searches for package
    -Si         : outputs info for package
    -Sp         : outputs only PKGBUILD
    -Su         : upgrades all AUR packages
    -Sc         : clears trizen pakage-kit cache
    -Ssq        : searches for package in quiet mode
    -G          : download and extract AUR tarball only
    -N          : outputs the AUR Newest Packages (RSS)
    -U          : installs local package from /tmp or cwd

$bred*$reset Other options
    -q          : quiet mode
    -C          : don't print comments
    -nc         : no color for text
    -nd         : no description for search results
    --auronly   : searches for a package only on AUR
    --movepkg   : after build, move pkg to the home directory
    --needed    : don't reinstall up to date packages
    --noedit    : do not prompt to edit files
    --devel     : update devel packages during -Su
    --noconfirm : do not prompt for any confirmation
    --skipinteg : when using makepkg, do not check md5s
    --help      : outputs this message

$bred*$reset Example: trizen -S bleachbit youtube-viewer -q --movepkg

";
}
sub die {
    die "\n  Try:\n\t$0 $a [pkgname]\n\n";
}
require LWP::UserAgent;
$lwp = 'LWP::UserAgent'->new;
$lwp->agent('Mozilla/5.0 (CLI; Trizen AUR Package Manager; U; en) Trizen/0.9');
$pacmanq = "\n" . `pacman -Qq` . "\n";
if ($all_argvs =~ / -(Q|R)/) {
    if ($all_argvs =~ / -Q/) {
        exec "pacman $all_argvs";
    } elsif ($all_argvs =~ / -R/) {
        foreach $pkgname (@ARGV) {
            next if $pkgname =~ /^-/;
            my $pkgname = quotemeta $pkgname;
            unless ($pacmanq =~ /\n$pkgname\n/) {
                $not_installed = 1;
                $packages .= $pkgname;
            }
        }
        if ($not_installed) {
            die "\n$bred [!]$reset Not installed: $packages\n\n";
        } else {
            &Remove_packages;
        }
    }
}
sub Remove_packages {
    print "\n$bred*$reset Executing: pacman $all_argvs\n\n";
    if ($whoami eq "root\n") {
        exec "pacman $all_argvs";
    } else {
        if ($cvr eq 'sudo') {
            print 'Sudo ';
            exec "$cvr pacman $all_argvs";
        } else {
            print 'Root ';
            exec qq[$cvr "pacman $all_argvs"];
        }
    }
}
sub Get_comments {
    unshift @Comments, "<$dep_name>";
    $AUR = $connect->content;
    $AUR =~ s/<div class="pgbox version">[^<]+//;
    $AUR =~ s/<([^>]+)>//g;
    $AUR =~ s/[\s]+Comment by:/\nComment by:/g;
    $AUR =~ s/Comment by:(.+)/$cblack$byellow$&$reset/g;
    $AUR = decode_entities($AUR);
    until (not $AUR =~ /\n[ \t]*\n/) {
        $AUR =~ s/\n[ \t]*\n/\n/g;
    }
    if ($AUR =~ /Show all [\d]+ comments/) {
        $AUR =~ s/$&[^~]+//;
    }
    $split = quotemeta $cblack;
    @AUR = split(/$split/, $AUR, 0);
    foreach $comment (@AUR) {
        if ($comment =~ /Comment by:/) {
            unshift @Comments, "$cblack$comment";
        }
    }
}
if ($tarball_only) {
    foreach $pkg (@args) {
        $pkg =~ s/\\//g;
        $pkg =~ s/\+/%2B/g;
        $lwp->mirror("$aur_pkgs$pkg/$pkg.tar.gz", "$pkg.tar.gz");
        if (-e "$pkg.tar.gz") {
            unless ($quiet) {
                print "$bred*$reset Unpacking $pkg.tar.gz\n";
            }
            `tar xf $pkg.tar.gz`;
            unlink "$pkg.tar.gz";
        } else {
            print "$bred!$reset error:$pkg doesn't exit\n";
            next;
        }
    }
    print "\n$bred*$reset Done...\n";
}
if ($all_argvs =~ / -S[y]?u /) {
    &Update;
}
if ($all_argvs =~ / -Sp /) {
    foreach $pkgname (@args) {
        print "\n$bred=>>$reset PKGBUILD for $pkgname\n";
        $pkgname =~ s/\+/%2B/g;
        $pkgbuild = $lwp->get("$aur_pkgs/$pkgname/PKGBUILD");
        print $pkgbuild->content;
        print "\n";
    }
    exit;
}
if ($all_argvs =~ / -U/) {
    require File::Find;
    File::Find::find(\&mktree, $location);
    sub mktree {
        push @local_files, $File::Find::name;
    }
    require Cwd;
    $cwd = Cwd::getcwd();
    @cwd_file = glob("$cwd/*");
    foreach $pkgname (@ARGV) {
        next if $pkgname =~ /^-/;
        my $pkgname = quotemeta $pkgname;
        foreach $local_pkg (@cwd_file) {
            if ($local_pkg =~ m[.+${pkgname}[^/]*\.pkg\.tar.*] 
            or $local_pkg =~ m[^$cwd/$pkgname$] and $local_pkg =~ /\\\.pkg\\\.tar/) {
                print "\n$bred*$reset Installing: $&\n\n";
                &Install_local_package($&);
            }
        }
    }
    foreach $pkgname (@ARGV) {
        next if $pkgname =~ /^-/;
        my $pkgname = quotemeta $pkgname;
        foreach $local_pkg (@local_files) {
            if ($local_pkg =~ m[.*[^/]*${pkgname}[^\/]*\.pkg\.tar.*]) {
                print "\n$bred*$reset Installing: $&\n\n";
                &Install_local_package($&);
            } elsif ($local_pkg =~ /.*$pkgname$/ and $pkgname =~ /\\\.pkg\\\.tar/) {
                print "\n$bred*$reset Installing: $local_pkg\n\n";
                &Install_local_package($local_pkg);
            }
        }
    }
}
sub Install_local_package {
    if ($whoami eq "root\n") {
        system "pacman -U $_[0]";
    } else {
        if ($cvr eq 'sudo') {
            print 'Sudo ';
            system qq[$cvr "pacman -U "$_[0]""];
        } else {
            print 'Root ';
            system qq[$cvr "pacman -U "$_[0]""];
        }
    }
}
if ($all_argvs =~ / -Ss[q]? /) {
    $keywords = join(' ', @args);
    if ($all_argvs =~ / -Ss /) {
        unless ($auronly) {
            system "pacman -Ss $keywords";
        }
    } else {
        unless ($auronly) {
            system "pacman -Ssq $keywords";
        }
    }
    $rpc .= 'search';
    foreach $keyword (@args) {
        $rpc .= "&arg=$keyword";
    }
    $rpc =~ s/\+/%2B/g;
    $connect = $lwp->get($rpc);
    @results = split(/"ID":"\d+",/, $connect->content, 0);
}
if ($all_argvs =~ / -Ss[q]? /) {
    foreach $result (@results) {
        &Check_result;
    }
    &Parse_results;
}
sub Check_aur_deps {
    ++$n;
    $aur_url = "$aur_website$id";
    unless ($checked or $quiet) {
        print "$bred=>> $cblack${byellow}Checking for AUR deps$reset\n";
        $checked = 1;
    }
    unless ($quiet) {
        printf "$bred*$reset AUR - $aur_url";
    }
    $connect = $lwp->get($aur_url);
    if ($connect->content =~ m[([^/]+)/PKGBUILD]) {
        $dep_name = $1;
        unless ($quiet) {
            print " ($dep_name)\n";
        }
        if ($dep_name ne $pkgname and not grep {$_ eq $dep_name;} @final_aur_deps) {
            push @final_aur_deps, $dep_name;
        }
    }
    if ($show_comments) {
        &Get_comments;
    }
    $aur_deps = $connect->content;
    $aur_deps =~ s/Required by.*//;
    @aur_deps = split(/\s/, $aur_deps, 0);
    foreach $line (@aur_deps) {
        next if $line eq $lastline;
        if ($line =~ m[^href='packages.php\?ID=[\d']+>(.+)</a>]) {
            $dep = $1;
            $dep =~ s/^\s|\s$//g;
            $dep =~ s/[<>]+.+//;
            $dep =~ s/=.+//;
            if (grep {$_ eq $lastdep;} @final_aur_deps and $id ne $firstid 
            and not grep {$_ eq $dep;} @final_aur_deps) {
                unshift @final_aur_deps, $dep;
            } elsif (not grep {$_ eq $dep;} @final_aur_deps) {
                push @final_aur_deps, $dep;
            }
            $lastdep = $dep;
            unless ($quiet) {
                print "    $bred>$reset Found: $lastdep\n";
            }
        }
        if ($line =~ m[packages/search/\?q=([^'"]+)]) {
            $pac_dep = $1;
            $pac_dep =~ s/[<>]+.+//;
            $pac_dep =~ s/=.+//;
            push @pacman_deps, $1;
        }
        $lastline = $line;
    }
}
sub Install {
    foreach $pkg (@packages_for_install) {
        $installed = "\n" . `pacman -Qq` . "\n";
        $pacmanq = $installed;
        if ($pkg ne $pkgname) {
            next if $installed =~ /\n$pkg\n/;
        }
        $pkg =~ s/\+/%2B/g;
        $connect = $lwp->get("$info$pkg");
        next if $connect->content =~ /"results":"No result found"/;
        $tarball = "$aur_pkgs$pkg/$pkg.tar.gz";
        $pkg =~ s/%2B/+/g;
        unless ($quiet) {
            print "\n$bred*$reset Downloading '${pkg}' tarball\n";
        }
        $lwp->mirror($tarball, "$cache_dir/$pkg.tar.gz");
        unless ($quiet) {
            print "$bred*$reset Saved as $cache_dir/$pkg.tar.gz\n";
            print "$bred*$reset Done.\n\n";
            print "$bred*$reset Unpacking tarball...\n";
        }
        `tar xf $cache_dir/$pkg.tar.gz -C $cache_dir`;
        if ($ENV{'EDITOR'}) {
            $editor = $ENV{'EDITOR'};
        } elsif (-e '/usr/bin/joe') {
            $editor = 'joe';
        } elsif (-e 'usr/bin/vim') {
            $editor = 'vim';
        } elsif (-e '/usr/bin/nano') {
            $editor = 'nano';
        } elsif (-e '/usr/bin/vi') {
            $editor = 'vi';
        } else {
            $editor = 'NULL';
        }
        next unless open FILE, "$cache_dir/$pkg/PKGBUILD";
        @file = <FILE>;
        close FILE;
        if (@Comments and $show_comments and not $quiet) {
            $comments = join('', @Comments);
            $comments =~ s/\n/></g;
            if ($comments =~ /(.+)<$pkg>/) {
                $comments = $1;
                $comments =~ s/></\n/g;
                $comments =~ s/[>]?([^<]+).+/$1/;
                print "\n$comments";
            } else {
                $comments = '';
            }
        }
        print "\n$bred=>>$reset PKGBUILD of $pkg\n\n";
        print @file;
        print "\n";
        unless ($noconfirm or $noedit) {
            print "$bred=>>$reset Edit $cblack$byellow$pkg$reset PKGBUILD with '${editor}'? (y/N)\n> ";
            chomp($yn = <STDIN>);
            if ($yn =~ /^y/i) {
                system "$editor $cache_dir/$pkg/PKGBUILD";
            }
        }
        chdir "$cache_dir/$pkg";
        if ($whoami eq "root\n") {
            system $rootmake;
        } else {
            system $usermake;
        }
        if ($movepkg) {
            if (`ls $cache_dir/$pkg` =~ /.+\.pkg\.tar.*/) {
                `mv $cache_dir/$pkg/$& $ENV{'HOME'}/`;
            }
        }
    }
}
sub Update {
    @aur_pkgs = `pacman -Qm`;
    foreach $line (@aur_pkgs) {
        chomp $line;
        next unless $line =~ /^[\w]+/;
        $line =~ s/\+/%2B/g;
        unless ($devel) {
            next if $line =~ /-(svn|cvs|hg|bzr|darcs|git)/;
        }
        if ($line =~ /(.+) (.+)/) {
            $pkgname = $1;
            $vers = $2;
        }
        if ($lwp->get("$info$pkgname")->content =~ /"Name":"([^"]+)".*Version":"([^"]+)".*OutOfDate":"([\d]+)"/) {
            $name = $1;
            $vvv = $2;
            $ood = $3;
            if ($vers ne $vvv) {
                $vers_nr = $vers;
                $vers_nr =~ s/[^\d]+//g;
                $vvv_nr = $vvv;
                $vvv_nr =~ s/[^\d]+//g;
                if (length $vvv_nr < length $vers_nr) {
                    $vvv_nr .= 0;
                }
                if ($vvv_nr > $vers_nr and not $line =~ /-(svn|cvs|hg|bzr|darcs|git)/) {
                    push @ood_packages, $name;
                    push @for_upgrade, "$bred*$reset $name $bred$vers$reset -> $bgreen$vvv$reset\n";
                }
            }
            if ($devel and $line =~ /-(svn|cvs|hg|bzr|darcs|git)/) {
                push @ood_packages, $name;
                push @for_upgrade, "$bred*$reset $name\n";
            }
            $v2 = $vvv;
            if ($ood eq 1) {
                $v2 = 'ood';
            }
            $line =~ s/%2B/+/g;
            print "$bred*$reset $line";
            if ($vers eq $vvv) {
                if ($v2 eq 'ood') {
                    print $bred . ' (out-of-date)';
                    print $reset;
                }
                print "\n";
            } elsif ($vvv ne $vers) {
                if ($vvv_nr > $vers_nr) {
                    print " $bgreen(New Update: $vvv)$reset";
                } elsif (not $devel || $vvv =~ /20(09|1(0|1|2))[\d]+/) {
                    print " (${bgreen}AUR Version: $bred$vvv$reset)";
                }
                if ($v2 eq 'ood') {
                    print " $bred(out-of-date)$reset";
                }
                print "\n";
            }
        }
    }
    if (@ood_packages) {
        print "\n\n$bred=>>$reset Packages for upgrade:";
        print "\n" . '=' x 80 . "\n";
        print @for_upgrade;
        print '=' x 80 . "\n";
        foreach $pkgname (@ood_packages) {
            print "
$bred*$reset Do you want to upgrade $cblack$byellow$pkgname$reset ? (Y/n)
> ";
            chomp($y = <STDIN>);
            if ($y =~ /^y|^$/i) {
                print "    ->> $bgreen$pkgname$reset will be upgraded\n";
                push @ARGV, $pkgname;
            } else {
                next;
            }
        }
        &Pre_install;
    } else {
        print "\n$bgreen* Your AUR Packages are up to date.\n\n";
        exit;
    }
}
if ($all_argvs =~ / -S /) {
    &Pre_install;
}
sub Pre_install {
    foreach $pkgname (@ARGV) {
        next if $pkgname =~ /^-/;
        $checked = '';
        $pkg = $pkgname;
        $installing = 1;
        &Info;
        splice @packages_for_install;
        splice @pacman_deps;
        splice @final_aur_deps;
        splice @pacman_deps2;
        splice @deps_ids;
        if ($connect->content =~ /"results":"No result found"/) {
            $check_pacman = `pacman -S --print $pkgname`;
            if ($check_pacman =~ m[://]) {
                print "
$bred=>>$reset Installing '$bgreen$pkgname${reset}' with pacman
";
                if ($whoami eq "root\n") {
                    if ($needed) {
                        my $pkgname = quotemeta $pkgname;
                        unless ($pacmanq =~ /\n$pkgname\n/) {
                            system "pacman -S $pkgname --needed";
                        }
                    } else {
                        system "pacman -S $pkgname";
                    }
                } else {
                    if ($needed) {
                        my $pkgname = quotemeta $pkgname;
                        unless ($pacmanq =~ /\n$pkgname\n/) {
                            if ($cvr ne 'sudo') {
                                print "\nRoot ";
                            } else {
                                print "\nSudo ";
                            }
                            system qq[$cvr "pacman -S $pkgname --needed"];
                        }
                    } else {
                        if ($cvr ne 'sudo') {
                            print "\nRoot ";
                        } else {
                            print "\nSudo ";
                        }
                        system qq[$cvr "pacman -S $pkgname"];
                    }
                }
                print "\n";
                next;
            } else {
                next;
            }
        }
        if ($connect->content =~ /"OutOfDate":"1"}}$/) {
            $out_of_date = 1;
        }
        if ($connect->content =~ /^{"type":"info","results":{"ID":"([^"]+)"/) {
            $id = $1;
            unless ($firstid) {
                $firstid = $id;
            }
            foreach $_ (@all_depends) {
                $AUR_dep = quotemeta $_;
                unless ($pacmanq =~ /\n$AUR_dep\n/) {
                    $check_aur = 1;
                }
            }
            if ($check_aur) {
                &Check_aur_deps;
            }
            if ($pkgbuild_connect->content =~ /makedepends[\s]*=[\s]*([^\w]*)([^\)]*)/ 
            and not $pkgbuild_connect->content =~ /makedepends[\s]*=[\s]*\([\s'"]*\)/) {
                $makedepends = $2;
                $makedepends =~ s/[<>]+[^' "]+//g;
                $makedepends =~ s/=[^' "]+//g;
                $makedepends =~ s/([^\w\-\+]+)/\n/g;
                until (not $makedepends =~ /\n\n/) {
                    $makedepends =~ s/\n\n/\n/g;
                }
                @makedepends = split(/\n/, $makedepends, 0);
                foreach $makedepend (@makedepends) {
                    if ($makedepend eq 'pkgconfig') {
                        $makedepend = 'pkg-config';
                    }
                    $makedepend = quotemeta $makedepend;
                    next if $pacmanq =~ /\n$makedepend\n/;
                    $makedepend =~ s/\\//g;
                    $info_connect = $lwp->get("$info$makedepend");
                    if ($info_connect->content =~ /"ID":"([^"]+)"/) {
                        push @deps_ids, $1;
                    }
                    unless ($info_connect->content =~ /"results":"No result found"/) {
                        next;
                    }
                    push @pacman_deps, $makedepend;
                }
            }
        }
        foreach $aur_dep (@final_aur_deps) {
            $aur_dep = quotemeta $aur_dep;
            next if $pacmanq =~ /\n$aur_dep\n/ or $aur_dep eq $pkgname;
            $aur_dep =~ s/\\//g;
            $info_connect = $lwp->get("$info$aur_dep");
            if ($info_connect->content =~ /"ID":"([^"]+)"/) {
                push @deps_ids, $1;
            }
        }
        if (@deps_ids) {
            unless ($n) {
                $n = 0;
            }
            foreach $id (@deps_ids) {
                &Check_aur_deps;
            }
        }
        if ($check_aur) {
            print "\n";
        }
        print "${bred}[!]$reset $cblack${byellow}From AUR:$reset ";
        foreach $aur_dep (@final_aur_deps) {
            next if $pacmanq =~ /\n$aur_dep\n/;
            $aur_dep =~ s/\\//g;
            if ($aur_dep) {
                print "$aur_dep ";
                push @packages_for_install, $aur_dep;
            }
        }
        print "$pkgname ";
        $check_deps = join('#', @packages_for_install);
        $check_deps =~ s/$pkgname#//g;
        $check_deps =~ s/#$|^#//g;
        @packages_for_install = split(?#?, $check_deps, 0);
        push @packages_for_install, $pkgname;
        foreach $dep (@pacman_deps) {
            push @pacman_deps2, "$dep ";
        }
        $pacman_deps = join('', @pacman_deps2);
        $pacman_deps =~ s/[\s]+/ /g;
        until (not $pacman_deps =~ /  /) {
            $pacman_deps =~ s/  / /g;
        }
        @pacman_deps = split(' ', $pacman_deps, 0);
        @pacman_deps = sort  @pacman_deps;
        $pac_printed = '';
        foreach $dep (@pacman_deps) {
            next if $dep eq 'sh';
            next if $dep eq $lastdep;
            $dep = quotemeta $dep;
            unless ($pacmanq =~ /\n$dep\n/) {
                unless ($pac_printed) {
                    print "\n${bgreen}[*] $cblack${byellow}From Pacman:$reset ";
                    $pac_printed = 1;
                }
                $dep =~ s/\\//g;
                print "$dep ";
            }
            $lastdep = $dep;
        }
        if ($out_of_date) {
            print "\n\n$bred!$reset warning: '${pkgname}' has been flagged out of date";
        }
        $pkgname = quotemeta $pkgname;
        if ($pacmanq =~ /\n$pkgname\n/) {
            if ($out_of_date) {
                print "\n";
            } else {
                print "\n\n";
            }
            $pkgname =~ s/\\//g;
            if ($needed) {
                print "$bred!$reset warning: '${pkgname}' is already installed --skipping\n\n";
                next;
            }
            print "$bred!$reset warning: '${pkgname}' is already installed --reinstalling";
        }
        $check_aur = '';
        unless ($noconfirm) {
            print "\n\n$bred=>>$reset Proceed with build (Y/n)\n> ";
            chomp($yn = <STDIN>);
            unless ($yn =~ /^y|^$/i) {
                next;
            }
        }
        &Install;
    }
}
sub Check_result {
    $keyword = join('', @keys);
    if ($result =~ /^"Name":"[^"]*$keyword"/i) {
        push @final_results, $result;
    } elsif ($all_argvs =~ / -Ss[q]? / and $result =~ /"Description":"[^"]*$keyword"/i) {
        push @final_results, $result;
    }
}
sub Parse_results {
    $n = 0;
    @final_results = sort  @final_results;
    foreach $result (@final_results) {
        if ($result =~ /^"Name":"([^"]+)","Version":"([^"]*)","CategoryID":"([\d]+)","Description":"([^"]*)"/) {
            $name = $1;
            $ver = $2;
            $cat = $3;
            $desc = $4;
            ++$n;
        }
        if ($result =~ /"URL":"([^"]*)","URLPath":"([^"]*)","License":"([^"]*)","NumVotes":"([^"]*)","OutOfDate":"([^"]*)"[\},\{\]]*$/) {
            $url = $1;
            $votes = $4;
            $ood = $5;
        }
        $url =~ s[\\/][/]g;
        $desc =~ s[\\/][/]g;
        if ($all_argvs =~ / -Ss[q]? /) {
            &Print_results;
        }
    }
}
sub Print_results {
    &Parse_category;
    unless ($quiet) {
        print "$green$n. $bgreen";
    }
    print "$cblack$byellow$name$reset ";
    unless ($quiet) {
        print "$ver ";
        $name = quotemeta $name;
        if ($pacmanq =~ /\n$name\n/) {
            print "[$cgreen${byellow}installed$reset] ";
        }
        if ($ood eq 1) {
            print "[${bred}out-of-date$reset] ";
        }
        print "$cblack$byellow($votes+)$reset ($cat) ";
        unless ($nodesc) {
            print "$desc ";
        }
    }
    print "\n";
}
sub Parse_category {
    $cat =~ s/^2$/daemons/;
    $cat =~ s/^3$/devel/;
    $cat =~ s/^4$/editors/;
    $cat =~ s/^5$/emulators/;
    $cat =~ s/^6$/games/;
    $cat =~ s/^7$/gnome/;
    $cat =~ s/^8$/i18n/;
    $cat =~ s/^9$/kde/;
    $cat =~ s/^19$/kernels/;
    $cat =~ s/^10$/lib/;
    $cat =~ s/^11$/modules/;
    $cat =~ s/^12$/multimedia/;
    $cat =~ s/^13$/network/;
    $cat =~ s/^14$/office/;
    $cat =~ s/^15$/science/;
    $cat =~ s/^16$/system/;
    $cat =~ s/^17$/x11/;
    $cat =~ s/^18$/xfce/;
}
if ($all_argvs =~ / [-]+N /) {
    $url = 'http://aur.archlinux.org/rss.php';
    $connect = $lwp->get($url);
    $rss = $connect->content;
    $rss = decode_entities($rss);
    $rss =~ s[</link>[\s]*
[\s]*<description>|</author>[\s]*
[\s]*<pubDate>|</title>[\s]*
[\s]*<link>|</description>[\s]*
[\s]*<author>][---]g;
    @RSS = split(?\n?, $rss, 0);
    foreach $_ (@RSS) {
        if ($_ =~ m[<title>(.+)---(.+)---(.+)---(.+)---(.+)</pubDate>]) {
            print $green;
            print "\nTitle:";
            print $bgreen . "\t$1$reset\n";
            print $green;
            print 'Descr:';
            print "$green\t$3\n";
            print $green;
            print 'A.URL:';
            print $red . "\t$2\n";
            print $reset;
        }
    }
    print "\n";
    exit;
}
if ($all_argvs =~ / -Si /) {
    foreach $pkg (@args) {
        $pkg =~ s/\\//g;
        &Info;
    }
}
sub Info {
    $pkg =~ s/\+/%2B/g;
    $pkgbuild = "$aur_pkgs$pkg/PKGBUILD";
    $connect = $lwp->get("$info$pkg");
    if ($connect->content =~ /"results":"No result found"/) {
        if ($installing) {
            return;
        }
        $pkg =~ s/%2B/+/g;
        system "pacman -Si $pkg";
        next;
    }
    if ($connect->content =~ /"ID":"([^"]+)/) {
        $aur_id = $1;
    }
    if ($connect->content =~ /"NumVotes":"([^"]+)/) {
        $votes = $1;
    }
    if ($connect->content =~ /"OutOfDate":"([\d]+)/) {
        $out_of_date = $1;
    }
    if ($connect->content =~ /"Name":"([^"]+)/) {
        $pkg = $1;
    }
    if ($connect->content =~ /"Version":"([^"]+)/) {
        $version = $1;
        $pkgver = $1;
        $pkgver =~ s/-[\d]+$//g;
    }
    if ($connect->content =~ /"Description":"([^"]*)/) {
        $description = $1;
        $description =~ s[\\/][/]g;
        $description = decode_entities($description);
    }
    if ($connect->content =~ /"URL":"([^"]*)/) {
        $url = $1;
        $url =~ s[\\/][/]g;
    }
    if ($connect->content =~ /"CategoryID":"([^"]+)/) {
        $cat = $1;
        &Parse_category;
    }
    $pkgbuild_connect = $lwp->get($pkgbuild);
    if ($pkgbuild_connect->content =~ /\ndepends[\s]*=[\s]*\(([^\)]*)/) {
        $depends = $1;
        $depends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $depends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $depends =~ s/"|'//g;
        $depends =~ s/\n[\s]*/\n\t\t  /g;
        $depends =~ s/\\//g;
        $depends =~ s/^[\s]+|[\s]+$//g;
    }
    if ($pkgbuild_connect->content =~ /\nmakedepends[\s]*=[\s]*\(([^\)]*)/) {
        $makedepends = $1;
        $makedepends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $makedepends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $makedepends =~ s/"|'//g;
        $makedepends =~ s/\n[\s]*/\n\t\t  /g;
        $makedepends =~ s/\\//g;
        $makedepends =~ s/^[\s]+|[\s]+$//g;
    } else {
        $makedepends = 'None';
    }
    if ($pkgbuild_connect->content =~ /\noptdepends[\s]*=[\s]*\(([^\)]*)/) {
        $optdepends = $1;
        $optdepends =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $optdepends =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $optdepends =~ s/"|'//g;
        $optdepends =~ s/\n[\s]*/\n\t\t  /g;
        $optdepends =~ s/\\//g;
        $optdepends =~ s/^[\s]+|[\s]+$//g;
    } else {
        $optdepends = '';
    }
    $all_depends = "$depends ";
    if ($makedepends ne 'None') {
        $all_depends .= $makedepends;
    }
    $all_depends =~ s/^[\s]+|[\s]+$//g;
    $all_depends =~ s/[\s]+/ /g;
    $all_depends =~ s/[<>]+[^\s]+//g;
    $all_depends =~ s/=[^\s]+//g;
    @all_depends = split(' ', $all_depends, 0);
    if ($pkgbuild_connect->content =~ /\nlicense[\s]*=[\s]*(.+)/) {
        $license = $1;
        $license =~ s/[")(']//g;
        $license =~ s/#(.*)//;
    } else {
        $license = '';
    }
    if ($pkgbuild_connect->content =~ /\ngroups[\s]*=[\s]*(.+)/) {
        $groups = $1;
        $groups =~ s/['"\)\(]+//g;
    } else {
        $groups = '';
    }
    if ($pkgbuild_connect->content =~ /\nprovides[\s]*=[\s]*(.+)/) {
        $provides = $1;
        $provides =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $provides =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
        $provides =~ s/['"\)\(]+//g;
    } else {
        $provides = '';
    }
    if ($pkgbuild_connect->content =~ /\nconflicts[\s]*=[\s]*(.+)/) {
        $conflicts = $1;
        $conflicts =~ s/['"\(\)]+//g;
        $conflicts =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $conflicts =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
    } else {
        $conflicts = '';
    }
    if ($pkgbuild_connect->content =~ /\nreplaces[\s]*=[\s]*(.+)/) {
        $replaces = $1;
        $replaces =~ s/['"\)\(]+//g;
        $replaces =~ s/\$[\{]?pkgname[\}]?/$pkg/g;
        $replaces =~ s/\$[\{]?pkgver[\}]?/$pkgver/g;
    } else {
        $replaces = '';
    }
    if ($pkgbuild_connect->content =~ /\narch[\s]*=[\s]*(.+)/) {
        $arch = $1;
        $arch =~ s/['"\(\)]+//g;
    }
    unless ($url =~ /[\w]+/) {
        $url = 'None';
    }
    unless ($groups =~ /[\w]+/) {
        $groups = 'None';
    }
    unless ($depends =~ /[\w]+/) {
        $depends = 'None';
    }
    unless ($optdepends =~ /[\w]+/) {
        $optdepends = 'None';
    }
    unless ($makedepends =~ /[\w]+/) {
        $makedepends = 'None';
    }
    unless ($provides =~ /[\w]+/) {
        $provides = 'None';
    }
    unless ($conflicts =~ /[\w]+/) {
        $conflicts = 'None';
    }
    unless ($replaces =~ /[\w]+/) {
        $replaces = 'None';
    }
    $pkg = quotemeta $pkg;
    if ($pacmanq =~ /\n$pkg\n/) {
        $yn = 'Yes';
    } else {
        $yn = 'No';
    }
    $pkg =~ s/\\//g;
    print "\n$bred*$reset Repository\t: ${bred}AUR\n";
    print "$bred*$reset Name\t\t: $bgreen$pkg\n";
    print "$bred*$reset Version\t: $version\n";
    print "$bred*$reset Category\t: $cat\n";
    print "$bred*$reset Out Of Date\t: ";
    if ($out_of_date eq 1) {
        print "${bred}Yes\n";
    } else {
        print "No\n";
    }
    print "$bred*$reset Installed\t: ";
    if ($yn eq 'Yes') {
        print "${bgreen}Yes\n";
    } else {
        print "No\n";
    }
    print "$bred*$reset Votes\t\t: $votes\n";
    print "$bred*$reset URL\t\t: $url\n";
    print "$bred*$reset AUR URL\t: $bgreen$aur_website$aur_id\n";
    print "$bred*$reset License";
    if ($license =~ /[\w]+ [\w]+/) {
        print 's';
    }
    print "\t: $license\n";
    if ($groups ne 'None') {
        print "$bred*$reset Groups\t: $groups\n";
    }
    if ($provides ne 'None') {
        print "$bred*$reset Provides\t: $provides\n";
    }
    print "$bred*$reset Depends On\t: $depends\n";
    if ($makedepends ne 'None') {
        print "$bred*$reset Make Depends\t: $makedepends\n";
    }
    if ($optdepends ne 'None') {
        print "$bred*$reset Optional Deps\t: $optdepends\n";
    }
    if ($conflicts ne 'None') {
        print "$bred*$reset Conflicts\t: ";
        if ($conflicts ne 'None') {
            print "$bred";
        }
        print "$conflicts\n";
    }
    if ($replaces ne 'None') {
        print "$bred*$reset Replaces\t: $replaces\n";
    }
    print "$bred*$reset Architecture\t: $arch\n";
    print "$bred*$reset Description\t: $description\n\n";
}
exit;
